<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<script src="BinarySearchTree.js"></script>
	
	<script>
		// SVG setup variables
		var height = 600;
		var width = 1000;
		var duration = 1500;
		var margin = {
				"top":50,
				"bottom":20,
				"left":10,
				"right":10
		}
		
		// how big we want the nodes to be
		var nodeRadius = 20;
		// ditto, except using d3.svg.symbol
		var nodeSize = 1000;
	</script>
	<style>
		text.node-null {
			font-size:7pt;
		}
		
		text.node-key {
			font-weight:bold;
		}
	</style>
</head>
<body>

<script>


// create a svg element and assign a d3 handle to it
var svg = d3.select("body").append("svg")
	.attr("height", height + margin.top + margin.bottom)
	.attr("width", width + margin.left + margin.right)
	.append("g")
		.attr("width", width)
		.attr("height", height)
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");


// instantiate a d3 tree layout
var tree = d3.layout.tree()
			.sort(null)
			.size([width,height])
			// this specifies how the children of each node is accessed
			.children( function (d) {
				return (d.left == null && d.right == null) ? null : 
					[ d.left, d.right];
			});

// Edges between nodes as a <path class="link" />
var link = d3.svg.diagonal()
    .projection(function(d)
    {
        return [d.x, d.y];
    });


// function to draw the tree
function drawTree(searchTree) {
	var nodes = tree.nodes(searchTree.getNodes());
	var links = tree.links(nodes);
	
	var edges = svg.selectAll(".edge")
		.data(links, function (d) { 
			return d.target.id; 
		});
	
	edges.enter()
		.insert("path", "g")
			.attr("class", "edge")
			.attr("fill", "none")
			.attr("stroke", "black")
			.attr("d", function (d) {
				var o = { x: d.source.x, y: d.source.y};
				return link({source:o, target:o});
			});
	
	edges.transition()
		.duration(duration)
		.attr("d", link);
		
	var node = svg.selectAll(".node")
		.data(nodes, function(d) { return d.id;});
	
	var nodeEnter = node.enter()
		.append("g")
			.attr("class", "node")
			.attr("width", nodeRadius * 2)
			.attr("height", nodeRadius * 2)
			.attr("transform", function (d) {
				if (d.depth > 0) { // not root node
					return "translate(" + d.parent.x + "," + d.parent.y + ")";
				}
				else {
					return "translate(" + width / 2 + ", " + 0 + ")";
				}
			});
	
	nodeEnter.transition()
			.attr("transform", function(d) {
				return "translate(" + d.x + ", " + d.y + ")";
			});
			
	nodeEnter.append("path")
		.attr("class", function (d) {
			if (d.key === null)
				return "node-null";
			else
				return "node-key";
		})
		.attr("d", d3.svg.symbol()
			.size(function (d) {
				if (d.key === null)
					return nodeSize - 300;
				else
					return nodeSize;
			})
			.type(function (d) {
				if (d.key === null) {
					return "square";
				}
				else {
					return "circle";
				}
			}));
	
	nodeEnter.append("text")
		.attr("class", function (d) {
			if (d.key === null)
				return "node-null";
			else
				return "node-key";
		})
		.attr("fill", "white")
		.attr("text-anchor", "middle")
		.attr("dominant-baseline", "central")
		.text(function (d) {
			return (d.key === null) ? "null" : d.key;
		});
	
	var nodeUpdate = node.transition()
		.duration(duration)
		.attr("transform", function(d) { 
			return "translate(" + d.x + ", " + d.y + ")";
		});
	
	nodeUpdate.select("path")
		.attr("class", function (d) {
			if (d.key === null)
				return "node-null";
			else
				return "node-key";
		})
		.attr("d", d3.svg.symbol()
			.size(function (d) {
				if (d.key === null)
					return nodeSize - 300;
				else
					return nodeSize;
			})
			.type(function (d) {
				if (d.key === null) {
					return "square";
				}
				else {
					return "circle";
				}
			}));
	
	nodeUpdate.select("text")
		.attr("class", function (d) {
			if (d.key === null)
				return "node-null";
			else
				return "node-key";
		})
		.attr("fill", "white")
		.attr("text-anchor", "middle")
		.attr("dominant-baseline", "central")
		.text(function (d) {
			return (d.key === null) ? "null" : d.key;
		});
	
	var nodeExit = node.exit()
		.transition()
		.duration(duration)
		.attr("r", 0)
		.remove();
		
}

//create a new tree
var bst = new BinarySearchTree();

//insert some nodes
var keys = [ 50, 30, 15, 20, 22, 35, 60, 75, 70, 80, 55, 21, 24, 23 ];
var counter = 0;
var inter = window.setInterval(function () {
	bst.insert(keys[counter]);
	drawTree(bst);
	counter++;
},2000);


</script>
</body>
</html>